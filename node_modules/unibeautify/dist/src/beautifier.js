"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LanguageManager_1 = require("./LanguageManager");
const OptionsManager_1 = require("./OptionsManager");
const InlineFlagManager_1 = require("./InlineFlagManager");
const DependencyManager_1 = require("./DependencyManager");
const utils_1 = require("./utils");
/**
Beautifier
*/
class Unibeautify {
    constructor() {
        this.options = {};
        this.languages = [];
        this.beautifiers = [];
        this.languageManager = new LanguageManager_1.LanguageManager(this.languages);
        this.optionsManager = new OptionsManager_1.OptionsManager(this.options);
    }
    /**
     * Get loaded languages which have a loaded beautifier supporting the given option
     */
    getLanguagesSupportingOption(optionName) {
        return this.supportedLanguages.filter(language => this.beautifiers.findIndex(beautifier => this.doesBeautifierSupportOptionForLanguage({
            beautifier,
            language,
            optionName,
        })) !== -1);
    }
    /**
     * Get options supported for language and all loaded beautifiers
     */
    getOptionsSupportedForLanguage(language) {
        return this.beautifiers.reduce((options, beautifier) => (Object.assign({}, options, this.getOptionsSupportedByBeautifierForLanguage({
            beautifier,
            language,
        }))), {});
    }
    /**
     * Get options supported by beautifier for a language.
     */
    getOptionsSupportedByBeautifierForLanguage({ beautifier, language, }) {
        const keys = OptionsManager_1.optionKeys(beautifier, language);
        const allOptions = this.optionsManager.options;
        return keys.reduce((options, key) => {
            const option = allOptions[key];
            if (!option) {
                return options;
            }
            return Object.assign({}, options, { [key]: option });
        }, {});
    }
    /**
     * Get all loaded languages which have at least one supporting beautifier.
     */
    get supportedLanguages() {
        return this.getLoadedLanguages().filter(language => Boolean(this.getBeautifierForLanguage(language)));
    }
    /**
    Beautify code
    */
    beautify(data) {
        const lang = this.languageManager.getLanguage(data);
        if (lang == null) {
            return Promise.reject(new Error("Cannot find language."));
        }
        const langOptions = Unibeautify.getOptionsForLanguage(lang, data.options);
        const { selectedBeautifiers, missingBeautifierName, } = this.beautifiersForLanguageAndOptions(lang, langOptions);
        if (selectedBeautifiers.length === 0) {
            return Promise.reject(new Error(`Beautifiers not found for Language: ${lang.name}`));
        }
        if (missingBeautifierName) {
            return Promise.reject(new Error(`Beautifier not found: ${missingBeautifierName}`));
        }
        return this.beautifyWithBeautifiers({
            beautifiers: selectedBeautifiers,
            fileExtension: data.fileExtension,
            filePath: data.filePath,
            langOptions,
            language: lang,
            projectPath: data.projectPath,
            text: data.text,
        });
    }
    beautifiersForLanguageAndOptions(lang, langOptions) {
        const allBeautifiers = this.getBeautifiersForLanguage(lang);
        const beautifierNames = langOptions.beautifiers || [];
        const selectedBeautifiers = beautifierNames.length > 0
            ? this.beautifiersWithNames(beautifierNames, allBeautifiers)
            : allBeautifiers;
        const missingBeautifierName = selectedBeautifiers
            .map((curr, index) => (curr ? undefined : beautifierNames[index]))
            .find(curr => !!curr);
        return {
            missingBeautifierName,
            selectedBeautifiers,
        };
    }
    beautifiersWithNames(names, beautifiers) {
        const beautifiersByName = beautifiers.reduce((index, current) => {
            index[current.name] = current;
            return index;
        }, {});
        return names.map(name => beautifiersByName[name]);
    }
    // tslint:disable:max-func-body-length
    beautifyWithBeautifiers({ beautifiers, language, langOptions, fileExtension, filePath, projectPath, text, }) {
        return beautifiers.reduce((promise, beautifier) => {
            const options = Unibeautify.getOptionsForBeautifier(beautifier, language, langOptions);
            return promise.then(currentText => {
                const beautifierOptions = langOptions[beautifier.name] || {};
                const dependencyManager = new DependencyManager_1.DependencyManager(beautifier.name, beautifier.dependencies || [], beautifierOptions);
                return dependencyManager
                    .load()
                    .then(() => {
                    if (beautifierOptions.prefer_beautifier_config &&
                        beautifier.resolveConfig) {
                        const resolveConfigPath = typeof beautifierOptions.prefer_beautifier_config === "string"
                            ? beautifierOptions.prefer_beautifier_config
                            : filePath;
                        return beautifier.resolveConfig({
                            dependencies: dependencyManager,
                            filePath: resolveConfigPath,
                            projectPath,
                        });
                    }
                    return Promise.resolve({});
                })
                    .then((beautifierConfig) => {
                    return beautifier
                        .beautify({
                        beautifierConfig,
                        dependencies: dependencyManager,
                        filePath: filePath,
                        language: language,
                        options,
                        projectPath: projectPath,
                        text: currentText,
                    })
                        .then(newText => {
                        if (typeof newText !== "string") {
                            return Promise.reject(new Error(`Beautifier response type must be "string" not "${typeof newText}": ${newText}`));
                        }
                        return Promise.resolve(newText);
                    })
                        .then((newText) => this.handleInlineFlags(currentText, newText));
                });
            });
        }, Promise.resolve(text));
    }
    handleInlineFlags(currentText, newText) {
        const manager = new InlineFlagManager_1.InlineFlagManager(currentText, newText);
        return manager.text;
    }
    /**
     * @deprecated use LanguageManager
     */
    findLanguages(query) {
        return this.languageManager.findLanguages(query);
    }
    /**
     * @deprecated use LanguageManager
     */
    getLoadedLanguages() {
        return this.languageManager.getLoadedLanguages();
    }
    /**
     * Get first loaded beautifier for given language.
     */
    getBeautifierForLanguage(language) {
        return this.beautifiers.find(beautifier => this.doesBeautifierSupportLanguage(beautifier, language));
    }
    /**
     * Find and return the appropriate Beautifiers for the given Language.
     */
    getBeautifiersForLanguage(language) {
        return this.beautifiers.filter(beautifier => this.doesBeautifierSupportLanguage(beautifier, language));
    }
    doesBeautifierSupportLanguage(beautifier, language) {
        return beautifier.options.hasOwnProperty(language.name);
    }
    /**
     * Get loaded beautifiers which have a loaded languages supporting the given option
     */
    getBeautifiersSupportingOption(optionName) {
        return this.beautifiers.filter(beautifier => this.languageManager.languages.findIndex(language => this.doesBeautifierSupportOptionForLanguage({
            beautifier,
            language,
            optionName,
        })) !== -1);
    }
    /**
     * Determine whether beautifier supports option for a language
     */
    doesBeautifierSupportOptionForLanguage({ beautifier, language, optionName, }) {
        return OptionsManager_1.optionKeys(beautifier, language).indexOf(optionName) !== -1;
    }
    /**
     * Find loaded languages the given beautifier supports.
     */
    getLanguagesForBeautifier(beautifier) {
        const { options } = beautifier;
        return this.languageManager.languages.filter(lang => options.hasOwnProperty(lang.name));
    }
    /**
     * Get a shallow copy of the options currently loaded.
     */
    get loadedOptions() {
        return this.optionsManager.loadedOptions;
    }
    /**
     * Get a shallow copy of the beautifiers currently loaded.
     */
    get loadedBeautifiers() {
        return this.beautifiers.slice();
    }
    /**
    Extract the Language-specific option values.
    */
    static getOptionsForLanguage(language, options) {
        const { name } = language;
        return options[name] || {};
    }
    /**
    Extract the option values that the Beautifier supports, including applying transformations.
    */
    static getOptionsForBeautifier(beautifier, language, options) {
        const beautifierOptions = beautifier.options[language.name];
        if (typeof beautifierOptions === "boolean" && beautifierOptions === false) {
            return {};
        }
        else if (typeof beautifierOptions === "object") {
            return Object.keys(beautifierOptions).reduce((acc, key) => {
                const option = beautifierOptions[key];
                if (typeof option === "string") {
                    return Object.assign({}, acc, { [key]: options[option] });
                }
                else if (typeof option === "function") {
                    return Object.assign({}, acc, { [key]: option(options[key]) });
                }
                else if (option === true) {
                    return Object.assign({}, acc, { [key]: options[key] });
                }
                else if (option instanceof Array) {
                    const [fields, fn] = option;
                    const values = fields.map(field => options[field]);
                    const obj = utils_1.zipObject(fields, values);
                    return Object.assign({}, acc, { [key]: fn(obj) });
                }
                // tslint:disable-next-line
                console.log(`Invalid option "${key}" with value ${JSON.stringify(option)}.`);
                return acc;
            }, {});
        }
        else {
            return options;
        }
    }
    /**
    Load a Beautifier
    */
    loadBeautifier(beautifier) {
        this.validateBeautifier(beautifier);
        this.beautifiers.push(beautifier);
        return this;
    }
    validateBeautifier(beautifier = {}) {
        if (!beautifier.name) {
            throw new Error('Beautifier is missing a "name" property.');
        }
        // tslint:disable-next-line:no-unused-expression
        new DependencyManager_1.DependencyManager(beautifier.name, beautifier.dependencies, {});
    }
    /**
    Load multiple beautifiers.
    */
    loadBeautifiers(beautifiers) {
        beautifiers.forEach(beautifier => this.loadBeautifier(beautifier));
        return this;
    }
    /**
     * Load a single language
     */
    loadLanguage(language) {
        this.languageManager.loadLanguage(language);
        return this;
    }
    /**
     * Load multiple languages
     */
    loadLanguages(languages) {
        this.languageManager.loadLanguages(languages);
        return this;
    }
    /**
     * Load multiple options
     */
    loadOptions(options) {
        this.optionsManager.loadOptions(options);
        return this;
    }
}
exports.Unibeautify = Unibeautify;
//# sourceMappingURL=beautifier.js.map