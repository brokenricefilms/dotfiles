"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
class LanguageManager {
    constructor(languages) {
        this.languages = languages;
    }
    getLanguage(data) {
        const filters = {
            atomGrammars: data.atomGrammar,
            extensions: data.fileExtension,
            name: data.languageName,
            sublimeSyntaxes: data.sublimeSyntax,
            vscodeLanguages: data.vscodeLanguage,
        };
        const langs = this.findLanguages({
            atomGrammar: data.atomGrammar,
            extension: data.fileExtension,
            name: data.languageName,
            sublimeSyntax: data.sublimeSyntax,
            vscodeLanguage: data.vscodeLanguage,
        });
        return this.getBestMatchLanguage(langs, filters);
    }
    /**
    Find and return the appropriate Languages that match any of the given filter criteria.
    An empty array will be returned if there are no matches.
  
    Precedence:
    - name
    - namespace
    - extension
    - atomGrammar
    - sublimeSyntax
    - vscodeLanguage
    */
    findLanguages(query) {
        const filters = {
            name: query.name,
            namespace: query.namespace,
            // tslint:disable-next-line:object-literal-sort-keys
            extensions: query.extension,
            atomGrammars: query.atomGrammar,
            sublimeSyntaxes: query.sublimeSyntax,
            vscodeLanguages: query.vscodeLanguage,
        };
        const langs = utils_1.filterMultiCriteria(this.languages, filters);
        return utils_1.unique(langs);
    }
    getBestMatchLanguage(langs, filters) {
        let bestMatch = langs[0];
        let highest = 0;
        const keys = Object.keys(filters);
        langs.forEach(lang => {
            let score = 0;
            keys.forEach(key => {
                const value = lang[key];
                if (Array.isArray(value)) {
                    if (filters[key] && value.indexOf(filters[key]) !== -1) {
                        score = score + 1;
                    }
                }
                else if (filters[key] === lang[key]) {
                    score = score + 1;
                }
            });
            if (score > highest) {
                bestMatch = lang;
                highest = score;
            }
        });
        return bestMatch;
    }
    /**
    Get a shallow copy of the languages currently loaded.
    */
    getLoadedLanguages() {
        return this.languages.slice();
    }
    /**
    Load a Language
    */
    loadLanguage(language) {
        this.languages.push(language);
        return this;
    }
    /**
    Load multiple Languages
    */
    loadLanguages(languages) {
        this.languages.push(...languages);
        return this;
    }
}
exports.LanguageManager = LanguageManager;
//# sourceMappingURL=LanguageManager.js.map