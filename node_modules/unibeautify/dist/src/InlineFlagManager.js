"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const diff_1 = require("diff");
class InlineFlagManager {
    constructor(oldText, newText) {
        this.oldText = oldText;
        this.newText = newText;
        this.oldLines = [];
        this.oldLines = oldText.split("\n");
        this.containsDisable =
            this.oldText.indexOf(InlineFlagPrefix.Disable) !== -1;
    }
    get text() {
        const { patch, oldText } = this;
        const afterPatchText = diff_1.applyPatch(oldText, patch);
        return this.fixEndOfFile(afterPatchText);
    }
    fixEndOfFile(text) {
        const shouldEndWithNewline = this.endsWithNewline(this.newText);
        const afterEndsWithNewline = this.endsWithNewline(text);
        if (shouldEndWithNewline === afterEndsWithNewline) {
            return text;
        }
        if (shouldEndWithNewline) {
            return `${text}\n`;
        }
        return text.slice(0, -1);
    }
    endsWithNewline(text) {
        return text.charAt(text.length - 1) === "\n";
    }
    get patch() {
        const { rawPatch } = this;
        const filteredHunks = this.filterHunks(rawPatch.hunks);
        return Object.assign({}, rawPatch, { hunks: filteredHunks });
    }
    get rawPatch() {
        const oldFileName = "Old";
        const newFileName = "New";
        const oldHeader = "";
        const newHeader = "";
        const options = {
            context: 0,
        };
        return diff_1.parsePatch(diff_1.createTwoFilesPatch(oldFileName, newFileName, this.oldText, this.newText, oldHeader, newHeader, options))[0];
    }
    filterHunks(hunks) {
        return hunks.filter(this.shouldApplyHunk.bind(this));
    }
    shouldApplyHunk(hunk) {
        const lineNumber = hunk.oldStart;
        return !(this.shouldIgnoreThisLine(lineNumber) || this.isDisabledAtLine(lineNumber));
    }
    shouldIgnoreThisLine(lineNumber) {
        const prevLineNum = lineNumber - 1;
        const prevLineCode = this.codeAtLine(prevLineNum);
        return Boolean(prevLineCode &&
            prevLineCode.indexOf(InlineFlagPrefix.IgnoreNextLine) !== -1);
    }
    isDisabledAtLine(lineNumber) {
        if (this.containsDisable) {
            const reversedLines = this.oldLines
                .slice(0, Math.max(0, lineNumber))
                .reverse()
                .join("\n");
            const disableIndex = reversedLines.indexOf(InlineFlagPrefix.Disable);
            const enableIndex = reversedLines.indexOf(InlineFlagPrefix.Enable);
            if (disableIndex !== -1 &&
                (enableIndex === -1 || disableIndex < enableIndex)) {
                return true;
            }
        }
        return false;
    }
    codeAtLine(lineNumber) {
        return this.oldLines[Math.max(0, lineNumber - 1)];
    }
}
exports.InlineFlagManager = InlineFlagManager;
var InlineFlagPrefix;
(function (InlineFlagPrefix) {
    InlineFlagPrefix["IgnoreNextLine"] = "unibeautify:ignore-next-line";
    InlineFlagPrefix["Enable"] = "unibeautify:enable";
    InlineFlagPrefix["Disable"] = "unibeautify:disable";
})(InlineFlagPrefix || (InlineFlagPrefix = {}));
//# sourceMappingURL=InlineFlagManager.js.map