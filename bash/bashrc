#!/usr/bin/env bash

if command -v tmux &>/dev/null && [ -n "$PS1" ] && [[ ! "$TERM" =~ screen ]] && [[ ! "$TERM" =~ tmux ]] && [ -z "$TMUX" ]; then
  tmux attach || tmux new-session && exit
fi

export PATH="$HOME/.gem/ruby/2.7.0/bin:$PATH"
export PATH="$HOME/.local/share/gem/ruby/3.0.0/bin:$PATH"
export PATH="$HOME/gems/bin:$PATH"

export PATH=$PATH:$HOME/dotfiles/bin
export PATH=$PATH:$HOME/.local/bin
export PATH=$PATH:$HOME/bin

export PATH=$PATH:$HOME/.cargo/bin

export PATH=$PATH:/usr/local/go/bin
export PATH=$PATH:$HOME/go/bin

export PATH="$HOME/.npm/bin:$PATH"
export PNPM_HOME="/home/master/.local/share/pnpm"
export PATH="$PNPM_HOME:$PATH"

export GEM_HOME="$HOME/gems"

export RIPGREP_CONFIG_PATH="$HOME/.ripgreprc"

export DENO_INSTALL="$HOME/.deno"
export PATH="$DENO_INSTALL/bin:$PATH"

export VISUAL="nvim"
export EDITOR=$VISUAL
export MANPAGER="nvim +Man!"
export EDITOR="nvim"

export BROWSER="google-chrome-stable"

export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_ALT_C_COMMAND="fd -t d"

export FZF_DEFAULT_OPTS=$FZF_DEFAULT_OPTS'
    --color=fg:#353535,bg:#eeeeee,hl:#353535
    --color=fg+:#353535,bg+:#e8e8e8,hl+:#353535
    --color=info:#353535,prompt:#353535,pointer:#353535
    --color=marker:#353535,spinner:#353535,header:#353535'

HISTCONTROL=ignoreboth
HISTSIZE=
HISTFILESIZE=
shopt -s histappend
shopt -s checkwinsize

bind "set completion-ignore-case on"

set -o vi

stty time 0

function parse_git_dirty {
  status=$(git status --porcelain -b 2>/dev/null)
  aheadRegex="ahead ([0-9]+)"
  behindRegex="behind ([0-9]+)"

  [[ $status =~ $aheadRegex ]] && ahead="${BASH_REMATCH[1]}" || ahead="0"
  [[ $status =~ $behindRegex ]] && behind="${BASH_REMATCH[1]}" || behind="0"

  [[ $(git status 2>/dev/null | tail -n1) != "nothing to commit, working tree clean" ]] && echo -n " 🍀"
  [[ $ahead != "0" ]] && echo -n " ↑${ahead}"
  [[ $behind != "0" ]] && echo -n " ↓${behind}"
}

function parse_git_stash {
  [[ $(git stash list 2>/dev/null | tail -n1) != "" ]] && echo " \/ stash"
}

function parse_git_branch {
  git branch --no-color 2>/dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(parse_git_dirty)$(parse_git_stash)/"
}

PS1='\[\e[0;2m\]\u\[\e[0;2m\]@\[\e[0;2m\]\H\[\e[0;2m\]: \[\e[0;1m\]\w \[\e[0;3m\]$(parse_git_branch)\n\[\e[0;2m\]❯ \[\e[0m\]'

alias bat="bat --theme=GitHub"

alias ser="browser_sync_start_server"
alias x="chmod +x"
alias q="exit"
alias ":q"="exit"
alias m="fzf_music"
alias o="fzf_open"
alias j="fzf_rg"
alias test_keyboard_input_code="sudo showkey"
alias open="xdg-open"
alias lazydocker="sudo $HOME/go/bin/lazydocker"
alias docker_start="sudo systemctl start docker"
alias docker="sudo docker"
alias docker-compose="sudo docker-compose"
alias google_art_download="dezoomify-rs (wl-paste)"
alias kitty_list_font="kitty +list-fonts --psnames"
alias create_astro="pnpm create astro@latest"
alias i="sudo dnf install -y"
alias u="sudo dnf remove -y"
alias r="trash"

alias bluetooth_connect_speaker_Pluse4="bluetoothctl connect C1:AC:88:3D:D6:EE"
alias bluetooth_disconnect_speaker_Pluse4="bluetoothctl disconnect C1:AC:88:3D:D6:EE"
alias bluetooth_restart_speaker_Pluse4="bluetooth_disconnect_speaker_Pluse4 ; bluetooth_connect_speaker_Pluse4"
alias bluetooth_turn_on="bluetoothctl power on"
alias bluetooth_turn_off="bluetoothctl power off"
alias bluetooth_devices="bluetoothctl devices"

alias ls="exa --icons"
alias ll="exa --long --header --icons --git"
alias tree="exa --tree --long"

alias c="fzf_change_directory"
alias cc="cd $HOME; fzf_change_directory"

alias e="fzf_edit_file"
alias e.="nvim ."
alias ee="cd $HOME; fzf_edit_file"
alias ej="fzf_emoji"
alias E="fzf_sudo_edit"

alias a="git add -A; git commit"
alias aa="git add -A; git commit -m 'auto commit'"
alias am="git add -A; git commit --amend --no-edit"
alias cdr="change_directory_to_git_root"
alias cl="clone_repo_in_clipboard"
alias l="git pull"
alias p="git push"
alias pp="git push -f"
alias s="git status -sb"
alias w="fzf_git_worktree_change_dir"
alias ww="fzf_git_worktree_remove"
alias aap="aa;p"

alias ...="cd .. ; cd .. ; ls"
alias ..="cd .. ; ls"
alias doc="cd ~/Documents ; ls"
alias dow="cd ~/Downloads ; ls"
alias tmp="cd /tmp ; ls"

is_in_git_repo() {
  git rev-parse HEAD >/dev/null 2>&1
}

function browser_daily() {
  xdg-open "https://www.inoreader.com/all_articles" &
  xdg-open "https://www.youtube.com/feed/subscriptions" &
  xdg-open "https://github.com" &
}

function download_audio() {
  if [ -z "$1" ]; then
    yt-dlp -f bestaudio --continue --no-overwrites --ignore-errors --extract-audio --audio-format mp3 -o "%(title)s.%(ext)s" "$(wl-paste)"
  else
    yt-dlp -f bestaudio --continue --no-overwrites --ignore-errors --extract-audio --audio-format mp3 -o "%(title)s.%(ext)s" "$1"
  fi
}

# TODO: checking playlist list to sync change, faster using parallel?
function sync_music() {
  CURRENT_DIR=$(pwd)
  MUSIC_DIR=$HOME/Music/

  cd $MUSIC_DIR
  trash *

  mkdir joji
  cd joji
  download_audio "https://l.thuanowa.com/music-joji"

  cd $MUSIC_DIR
  mkdir billie_eilish
  cd billie_eilish
  download_audio "https://l.thuanowa.com/music-billie-eilish"

  cd $MUSIC_DIR
  mkdir b_ray
  cd b_ray
  download_audio "https://l.thuanowa.com/music-b-ray"

  cd $MUSIC_DIR
  mkdir den_vau
  cd den_vau
  download_audio "https://l.thuanowa.com/music-den-vau"

  cd $MUSIC_DIR
  mkdir two_feet
  cd two_feet
  download_audio "https://l.thuanowa.com/music-two-feet"

  cd $MUSIC_DIR
  mkdir Alec_Benjamin
  cd music_alec_benjamin
  download_audio "https://l.thuanowa.com/music-alec-benjamin"

  cd $MUSIC_DIR
  mkdir English
  cd English
  download_audio "https://l.thuanowa.com/music-en"

  cd $MUSIC_DIR
  mkdir Vietnamese
  cd Vietnamese
  download_audio "https://l.thuanowa.com/music-vi"

  cd $MUSIC_DIR
  mkdir Korean
  cd Korean
  download_audio "https://l.thuanowa.com/music-ko"

  cd $MUSIC_DIR
  mkdir Japanese
  cd Japanese
  download_audio "https://l.thuanowa.com/music-ja"

  cd $MUSIC_DIR
  mkdir Japanese
  cd Japanese
  download_audio "https://l.thuanowa.com/music-ja"

  cd $MUSIC_DIR
  mkdir Spanish
  cd Spanish
  download_audio "https://l.thuanowa.com/music-spanish"

  cd $MUSIC_DIR
  mkdir Chinese
  cd Chinese
  download_audio "https://l.thuanowa.com/music-chinese"

  cd $MUSIC_DIR
  mkdir chill_hop
  cd chill_hop
  download_audio "https://l.thuanowa.com/music-chill-hop"

  cd $CURRENT_DIR
}

function update_bash_plugin() {
  cd ~/dotfiles/bash/
  curl --remote-name https://raw.githubusercontent.com/lincheney/fzf-tab-completion/master/bash/fzf-bash-completion.sh
  curl --remote-name https://raw.githubusercontent.com/junegunn/fzf/master/shell/key-bindings.bash
  curl --remote-name https://raw.githubusercontent.com/junegunn/fzf/master/shell/completion.bash
  git add .
  git commit -m "chore(bash): plugin"
}

function update_nvim_lazy() {
  CURRENT_DIR=$(pwd)

  cd $HOME/dotfiles/
  nvim --headless "+Lazy! sync" +qa
  git add nvim/lazy-lock.json
  git commit -m "chore: lazy.nvim"
  git push

  cd $CURRENT_DIR
}

function update() {
  dnf makecache
  pnpm add -g pnpm
  pnpm update -g
  tldr --update

  update_bash_plugin

  update_nvim_lazy
}

function browser_sync_start_server() {
  SERVER_IP=$(hostname -I)
  browser-sync start --server --files . --no-notify --host "$SERVER_IP" --port 9000
}

function browser_sync_start_server() {
  SERVER_IP=$(hostname -I)
  browser-sync start --server --files . --no-notify --host "$SERVER_IP" --port 9000
}

function change_directory_to_git_root() {
  cd $(git rev-parse --show-toplevel)
  ls
}

function clone_repo_in_clipboard() {
  url_to_username_repo=$(wl-paste | sed 's/.*m\///g')
  repo_name=$(wl-paste | sed 's/.*\///g')
  gh repo clone "$url_to_username_repo"
  cd "$repo_name"
}

function fzf_emoji() {
  default() {
    emoji-fzf preview --prepend | fzf | awk '{ print $1 }' | tr -d "\n" | wl-copy
  }

  if hash emoji-fzf 2>/dev/null; then
    default
  else
    pip install emoji-fzf
    default
  fi
}

function fzf_edit_file() {
  if [ -z "$1" ]; then
    FILE=$(fd --hidden --type file . | fzf --preview 'bat --theme=GitHub --color=always --style=numbers --line-range=:501 {}' &)

    if [ -n "$FILE" ]; then
      nvim "$FILE"
    fi
  else
    nvim "$1"
  fi
}

function fzf_sudo_edit() {
  if [ -z "$1" ]; then
    FILE=$(fd --hidden --type file . | fzf --preview 'bat --theme=GitHub --color=always --style=numbers --line-range=:501 {}' &)

    if [ -n "$FILE" ]; then
      sudoedit "$FILE"
    fi
  else
    sudoedit "$1"
  fi
}

function fzf_git_worktree_change_dir() {
  is_in_git_repo || return

  local worktrees
  local worktree
  local query
  local sess_arr
  local retval
  worktrees=$(git worktree list | fzf --exit-0 --print-query)
  retval=$?

  IFS=$'\n' read -rd '' -a sess_arr <<<"$worktrees"

  worktree=$(echo ${sess_arr[1]} | awk '{print $1}')
  query=${sess_arr[0]}

  if [ $retval == 0 ]; then
    if [ "$worktree" == "" ]; then
      worktree=$(echo "$query" | awk '{print $1}')
    fi
    cd "$worktree"
    tmux rename-window "$(git branch --show-current)"
  elif [ $retval == 1 ]; then
    DEFAULT_GIT_FOLDER=$(git worktree list | head --lines 1 | awk '{print $1}')

    mkdir $DEFAULT_GIT_FOLDER/.worktrees

    git worktree add $DEFAULT_GIT_FOLDER/.worktrees/"$query"

    cd $DEFAULT_GIT_FOLDER/.worktrees/"$query"

    git branch "$query"
    git checkout "$query"

    tmux rename-window "$(git branch --show-current)"
  fi
}

function fzf_git_worktree_remove() {
  is_in_git_repo || return

  WORKTREE=$(git worktree list | fzf | awk '{print $1}')
  DEFAULT_GIT_FOLDER=$(git worktree list | head --lines 1 | awk '{print $1}')

  git worktree remove $WORKTREE --force &>/dev/null
  cd $DEFAULT_GIT_FOLDER
}

function fzf_open() {
  if [ -z "$1" ]; then
    FILE=$(fd --hidden --type file . | fzf --preview 'bat --theme=GitHub --color=always --style=numbers --line-range=:500 {}' &)

    if [ -n "$FILE" ]; then
      xdg-open "$FILE"
    fi
  else
    xdg-open "$1"
  fi
}

function fzf_change_directory() {
  DIR=$1

  fzf_dir() {
    DIR=$(fd --hidden --type directory . | fzf --preview $'echo {} | tr -d \'()\' | awk \'{printf "%s ",  $2} {print  $1}\' | xargs -r ls' &)
    cd "$DIR"
    ls
  }

  if [ -z "$1" ]; then
    if [[ -n $DIR ]]; then
      cd $DIR &>/dev/null
      ERROR=$?

      if [[ ERROR -eq 1 ]]; then
        echo "\"$1\" directory does not exist"
        fzf_dir
      fi
    else
      fzf_dir
    fi
  else
    mkdir -p "$1"
    cd "$1"
  fi
}

function fzf_rg() {
  rg --color=always --line-number --no-heading --smart-case "${*:-}" |
    fzf --ansi --color "hl:-1:underline,hl+:-1:underline:reverse" --delimiter : --preview 'bat --theme=GitHub --color=always {1} --highlight-line {2}' --bind 'enter:become($EDITOR {1} +{2})'
}

function fzf_tldr() {
  tldr --list | sed "s/'//g" | sed "s/,//g" | sed "s/ /\n/g" | sed "s/]//g" | sed "s/\[//g" | fzf --preview "tldr {1}"
}

function tl() {
  if [ -z "$1" ]; then
    COMMAND=$(fzf_tldr &)
    tldr $COMMAND
  else
    tldr "$1"
  fi
}

function fzf_music() {
  CURRENT_DIR=$(pwd)

  cd ~/Music/

  PLAYLIST=$(fd --type directory . --exclude node_modules --exclude go | fzf --preview $'echo {} | tr -d \'()\' | awk \'{printf "%s ",  $2} {print  $1}\' | xargs -r ls' &)

  if [ -n "$PLAYLIST" ]; then
    cd $PLAYLIST
    mpv --loop-playlist --shuffle *
    cd $CURRENT_DIR
  else
    cd $CURRENT_DIR
  fi
}

function reload() {
  source ~/.bashrc

  tmux source ~/.tmux.conf

  ln -sf ~/dotfiles/application/* ~/.local/share/applications/
}

function reload_mouseless() {
  systemctl --user stop mouseless.service
  systemctl --user restart mouseless.service
}

function hi() {
  browser_daily
  update
  fastfetch
}

tmux_kill_all_unname_session() {
  CURRENT_DIR=$(pwd)
  cd /tmp/
  tmux ls | awk '{print $1}' | grep -o '[0-9]\+' >/tmp/killAllUnnameTmuxSessionOutput.sh
  sed -i 's/^/tmux kill-session -t /' killAllUnnameTmuxSessionOutput.sh
  chmod +x killAllUnnameTmuxSessionOutput.sh
  ./killAllUnnameTmuxSessionOutput.sh
  cd $CURRENT_DIR
}

copy_editor_config_file() {
  change_directory_to_git_root
  cp ~/dotfiles/template/skeleton.editorconfig .editorconfig
}

git_clone_all_remote_branch() {
  for branch in $(git branch -a | grep remotes | grep -v HEAD | grep -v master); do
    git branch --track ${branch#remotes/origin/} $branch
  done
}

git_clone_all_repo() {
  org=$1
  limit=9999

  cd ~/repos/

  repos="$(gh repo list "$org" -L $limit)"

  repo_total="$(echo "$repos" | wc -l)"
  repos_complete=0

  echo

  echo "$repos" | while read -r repo; do
    repo_name="$(echo "$repo" | cut -f1)"
    echo -ne "\r\e[0K[ $repos_complete / $repo_total ] Cloning $repo_name"
    gh repo clone "$repo_name" "$repo_name" -- -q 2>/dev/null || (
      cd "$repo_name"
      git_clone_all_remote_branch
    )
    repos_complete=$((repos_complete + 1))
  done

  echo "Finished cloning all repos in $org."
}

source ~/dotfiles/bash/fzf-bash-completion.sh
bind -x '"\t": fzf_bash_completion'
source ~/dotfiles/bash/completion.bash
source ~/dotfiles/bash/key-bindings.bash

export PATH="/home/master/.local/share/fnm:$PATH"
eval "$(fnm env)"
